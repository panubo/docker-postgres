#!/usr/bin/env bash


set -eo pipefail

# Source the upstream docker-entrypoint.sh functions
# shellcheck source=/dev/null
. /usr/local/bin/docker-entrypoint.sh

## Panubo functions

# Allow running early init scripts as root following similar convention
# as upstream docker image
process_entry_init_files() {
  for f in /entry-init.d/*; do
    case "$f" in
      *.sh)
        if [ -x "$f" ]; then
          echo "$0: running $f"
          "$f"
        else
          echo "$0: sourcing $f"
          # shellcheck source=/dev/null
          . "$f"
        fi
        ;;
      *)
        echo "$0: ignoring $f" ;;
    esac
    echo

    # Turn off error on undefined variables if it was turned on by an entry-init.d script
    set +u
  done
}

postgresql_conf() {
  if [[ ! -e "${PGDATA:-/var/lib/postgresql/data}/postgresql.base.conf" ]]; then
    cp "${PGDATA:-/var/lib/postgresql/data}/postgresql.conf" "${PGDATA:-/var/lib/postgresql/data}/postgresql.base.conf"
  fi

  printf "%s\n" \
    "# Do not edit this file manually!" \
    "# It will be overwritten by $0" \
    "include 'postgresql.base.conf'" \
    > "${PGDATA:-/var/lib/postgresql/data}/postgresql.conf"

  # Add include_if_exists variables
  local include_if_exists
  IFS=',' read -r -a include_if_exists <<<"${POSTGRES_INCLUDE_IF_EXISTS:-}"
  for item in "${include_if_exists[@]}"; do
    printf "%s\n" \
      "include_if_exists = '${item}'" \
      >> "${PGDATA:-/var/lib/postgresql/data}/postgresql.conf"
  done

  # Add wal-g config
  if [[ "${WALG_ENABLED:-}" = "true" ]] && [[ -n "${WALG_S3_PREFIX:-}" ]]; then
    echo "Info: WALG_ENABLED true"

    if [[ -n "${AWS_ENDPOINT:-}" ]] && [[ "${AWS_S3_FORCE_PATH_STYLE:-}" != "true" ]]; then
      echo "WARNING: looks like you are using a custom AWS_ENDPOINT but AWS_S3_FORCE_PATH_STYLE is not true, this may cause wal-g to fail to connect."
    fi
    printf "%s\n" \
      "wal_level = replica" \
      "archive_mode = on" \
      "archive_command = '/usr/bin/timeout 600 /usr/local/bin/wal-g wal-push %p'" \
      "archive_timeout = 600" \
      >> "${PGDATA:-/var/lib/postgresql/data}/postgresql.conf"
  elif [[ "${WALG_ENABLED:-}" = "true" ]] && [[ -z "${WALG_S3_PREFIX:-}" ]]; then
    echo "WARNING: WALG_ENABLED=true but WALG_S3_PREFIX is not set"
  fi

  printf "%s\n" \
    "max_connections = '${POSTGRES_MAX_CONNECTIONS:-100}'" \
    >> "${PGDATA:-/var/lib/postgresql/data}/postgresql.conf"

  printf "%s\n" \
    "shared_preload_libraries = 'timescaledb,pglogical,pg_stat_statements,pg_cron'" \
    >> "${PGDATA:-/var/lib/postgresql/data}/postgresql.conf"

  if [[ -e "${POSTGRES_SSL_CERT_FILE}" ]] && [[ -e "${POSTGRES_SSL_KEY_FILE}" ]]; then
    printf "%s\n" \
      "ssl = 'on'" \
      "ssl_cert_file = '${POSTGRES_SSL_CERT_FILE}'" \
      "ssl_key_file = '${POSTGRES_SSL_KEY_FILE}'" \
      >> "${PGDATA:-/var/lib/postgresql/data}/postgresql.conf"
  elif [[ -n "${POSTGRES_SSL_CERT_FILE}" ]] || [[ -n "${POSTGRES_SSL_KEY_FILE}" ]]; then
    echo "ERROR: ssl_cert_file or ssl_key_file set but files not found"
    exit 1
  fi

  # For postresql 12 or newer only
  # recovery.conf
  # recovery_target = ''
  # recovery_target_lsn = ''
  # recovery_target_name = ''
  # recovery_target_time = ''
  # recovery_target_timeline = 'latest'
  # recovery_target_xid = ''
  # restore_command = 'xxx'

  if [[ -n "${RECOVERY_WALG_S3_PREFIX:-}" ]] && [[ ! -e "${PGDATA}/recovery.signal.done" ]]; then
    printf "%s\n" \
      "restore_command = 'echo \"WAL file restoration: %f, %p\" && unset WALG_S3_PREFIX && /usr/local/bin/wal-g --config=/run/postgresql/recovery-wal-g.json wal-fetch \"%f\" \"%p\"'" \
      "recovery_end_command = 'touch recovery.signal.done && echo \"WAL file restoration complete\"'" \
      >> "${PGDATA:-/var/lib/postgresql/data}/postgresql.conf"
  fi

  printf "%s\n" \
    "cron.host = ''" \
    >> "${PGDATA:-/var/lib/postgresql/data}/postgresql.conf"

  echo "===postgres.conf==="
  cat "${PGDATA:-/var/lib/postgresql/data}/postgresql.conf"
  echo "===postgres.conf==="
}

docker_database_exists() {
  declare -g DATABASE_ALREADY_EXISTS
  # look specifically for PG_VERSION, as it is expected in the DB dir
  if [ -s "$PGDATA/PG_VERSION" ]; then
    DATABASE_ALREADY_EXISTS='true'
  fi
}

## Panubo override some functions
pg_setup_hba_conf() {

  local type_host hostnossl_reject postgres_exporter
  if [[ "${POSTGRES_ENFORCE_SSL}" == "true" ]]; then
    type_host="hostssl"
    hostnossl_reject=""
  else
    type_host="host"
    hostnossl_reject="# "
  fi

  if [[ -z "${POSTGRES_EXPORTER_PASSWORD:-}" ]]; then
    postgres_exporter="reject"
  else
    postgres_exporter="md5"
  fi

  printf "%s\n" \
    "# Do not edit this file manually!" \
    "# It will be overwritten by $0" \
    "" \
    "# TYPE  DATABASE        USER            ADDRESS                 METHOD" \
    "" \
    "# \"local\" is for Unix domain socket connections only" \
    "local   all             all                                     trust" \
    "${hostnossl_reject}hostnossl all,replication all                all                reject" \
    "${type_host}    all             postgres_exporter             all            ${postgres_exporter}" \
    "# IPv4 local connections:" \
    "${type_host}    all             all             127.0.0.1/32            md5" \
    "# IPv6 local connections:" \
    "${type_host}    all             all             ::1/128                 md5" \
    "# Allow replication connections from localhost, by a user with the" \
    "# replication privilege." \
    "local   replication     all                                     trust" \
    "" \
    "${type_host}    replication     all             all                     md5" \
    "${type_host}    replication     all             all                     md5" \
    "" \
    "${type_host}    all             all             all                     md5" \
    > "${PGDATA:-/var/lib/postgresql/data}/pg_hba.conf"
}

# This function is from https://github.com/docker-library/postgres/ with some modifications
main() {
  # if first arg looks like a flag, assume we want to run postgres server
  if [ "${1:0:1}" = '-' ]; then
    set -- postgres "$@"
  fi

  if [ "$1" = 'postgres' ] && ! _pg_want_help "$@"; then
    docker_setup_env
    # setup data directories and permissions (when run as root)
    docker_create_db_directories
    if [ "$(id -u)" = '0' ]; then
      # then restart script as postgres user
      exec gosu postgres "${BASH_SOURCE[0]}" "$@"
    fi

    # Process entry-init.d files
    process_entry_init_files

    # Recheck if the database already exists since it may have been loaded during entry-init.
    docker_database_exists

    # only run initialization on an empty data directory
    if [ -z "$DATABASE_ALREADY_EXISTS" ]; then
      docker_verify_minimum_env

      # check dir permissions to reduce likelihood of half-initialized database
      ls /docker-entrypoint-initdb.d/ > /dev/null

      docker_init_database_dir
      pg_setup_hba_conf
      postgresql_conf

      # PGPASSWORD is required for psql when authentication is required for 'local' connections via pg_hba.conf and is otherwise harmless
      # e.g. when '--auth=md5' or '--auth-local=md5' is used in POSTGRES_INITDB_ARGS
      export PGPASSWORD="${PGPASSWORD:-$POSTGRES_PASSWORD}"
      docker_temp_server_start "$@"

      docker_setup_db
      docker_process_init_files /docker-entrypoint-initdb.d/*

      docker_temp_server_stop
      unset PGPASSWORD

      echo
      echo 'PostgreSQL init process complete; ready for start up.'
      echo
    else

      # Reconfigured postgresql.conf and pg_hba.conf on each start
      pg_setup_hba_conf
      postgresql_conf

      echo
      echo 'PostgreSQL Database directory appears to contain a database; Skipping initialization'
      echo
    fi
  fi

  exec "$@"
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
